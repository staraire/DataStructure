# 第七章查找技术

## 1. 查找的基本概念

> 问题：在哪里找？

-- 查找表

- `查找表`是由同一类型的数据元素(或者记录)构成的`集合`。由于"集合"中的数据元素之间存在着**松散的关系**，因此查找表是一种灵便的结构。

> 问题：怎么查找？

-- 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或(记录)

- `关键字` 用来标识一个数据元素（或记录）的某个数据项的值
    - 主关键字：可唯一的标识一个记录的关键字是主关键字
    - 次关键字：反之，用以识别若干记录的关键字是次关键字

> 问题：查找成功否？

查找--根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或(记录)

- 若查找表中存在这样一个记录，则称"查找成功"
    - 查找结果给出整个记录的信息，或指示该记录在查找表中的位置
- 否则称"查找不成功"
    - 查找结果给出"空记录"或"空指针"

> 问题：查找目的是什么?

对查找表经常进行的操作
- 查询某个`特定的`数据元素`是否在`查找表中
- 检索某个`特定的`数据元素的`各种属性`
- 在查找表中`插入`一个数据元素
- `删除`查找表中的某个数据元素

> 问题：查找表怎么分类?

查找表可分为两类

- **`静态查找表`**
    - 仅作 `查询(检索)` 操作的查找表
- **`动态查找表`**
    - 做 `插入` 和 `删除` 操作的查找表
    - 有时在查询之后，还需要将 查询 结果为 不在查找表中 的数据元素`插入到`查找表中；或者，从查找表中`删除`其查询结果为在查找表中的数据元素，此类表为动态查找表

> 问题：如何评价查找算法?

查找算法的评价指标：
- 关键字的平均比较次数，也称平均查找长度 ASL(Average Search Length)

$ASL = \sum_{i=1}^np_ic_i$(关键字比较次数的期望值)

n：记录的次数
pi：查找第i个记录的概率(通常认为p=1/n)
ci：找到第i个记录需要比较的次数

> 问题：查找过程中我们需要研究什么?

`查找的方法`取决于查找表的结构，即表中数据元素是`依何种关系组织在一起的`。
由于对查找表来说，在集合中查询或检索一个特定的数据元素时，若无规律可循，只能对集合中的元素--加以辨认直至找到为止。

而这样的"查询"或"检索"是任何计算机应用系统中使用品读都很高的操作，因此设法`提高查找表的查找效率`，是本章讨论问题的出发点。

为提高查找效率，一个方法就是在构造查找表时，在集合中的数据元素之间人为的加上某种确定的约束关系。

研究查找表的各种组织方式及其查找过程的实施。


## 2. 线性表的查找

### 2.1. 顺序查找

- 应用范围
    - 顺序表或线性链表表示的`静态查找表`
    - 表内元素之间`无序`
    
- 顺序表的表示
    - 数据元素类型定义

```c
typedef struct{
    KeyType key; //关键字域
    ...          //其他域
}ElemType;
```

#### 顺序查找算法

```c
int Search_Seq(SSTable ST,KeyType key){
    for(i=ST.length;ST.R[i].key!=key;--i)
        if(i<=0)break;
    if(i>0) return i;
    else return 0;
}
```

或

```c
int Search_Seq(SSTable ST,KeyType key){
    for(i=ST.length;ST.R[i].key!=key&&i>0;--i)
    if(i>0) return i;
    else return 0;
}
```

改进：把待查关键字key存入表头("哨兵","监视哨")，从，可免去查找过程中每一步都要检测是否查找完毕，加快速度。

```c
int Search_Seq(SSTable ST,KeyType key){
    ST.R[0].key=key;
    for(i=ST.length;ST.R[i].key!=key;--i);
    return i;
}
```

- 时间效率分析
    - 时间复杂度：O(n)
    - 查找成功时的平均查找长度，设表中各记录查找概率相等
- 空间效率分析
    - 空间复杂度：一个辅助空间--O(1)

> 1、记录的查找概率不相等时如何提高查找效率

查找表存储记录原则--按查找效率高低存储
- 查找概率越高，比较次数越少
- 查找概率越低，比较次数越多 

> 2、记录的查找概率无法测定时如何提高查找效率。

方法-- 按查找概率动态调整记录顺序。
- 在每个记录中设一个访问频度域
- 始终保持记录按非递增有序的次序排列
- 每次查找后均将刚查到的记录直接移至表头。

#### 顺序查找的特点

- 优点：算法简单，逻辑次序无要求，且不同存储结构均适用。
- 缺点：ASL太长，时间效率太低。


### 2.2. 折半查找(二分查找或对分查找)

#### 折半查找性能分析

折半查找优点：效率比顺序查找高。
折半查找缺点：只适用于有序表，且限于顺序存储结构。



### 2.3. 分块查找

## 3. 树表的查找

- 当表插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录。
    - `改用动态查找表--几种特殊的树`。
    - 表结构在`查找过程中动态生成`。
    - 对于给定值Key，若表中存在，则成功返回，`否则，插入关键字等于key的记录`。

### 二叉排序树

- 二叉排序树又称为二叉搜索树，二叉查找树，定义
    - 二叉排序树或是空树，或是满足如下性质的二叉树：
        - 若其`左子树`非空，则左子树上所有结点的值`小于根节点`的值。
        - 若其`右子树`非空，则右子树上`所有结点的值大于等于根节点`的值。
        - 其左右子树本身又各是一棵二叉排序树。
        
- 二叉排序树的性质
    - 中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的递增有序序列
    
#### 二叉排序树的存储结构

```c
typedef struct{
    KeyType key; // 关键字项
    InfoType otherinfo;//其他数据域
}ElemType;
```

```c
typedef struct BSTNode{
    ElemType data; //数据域
    struct BSTNode *lchild,*rchild; //左右孩子指针
    
}BSTree T; //定义二叉排序树T
```

#### 二叉排序树的操作-查找

- 算法思想
    - 若查找的关键字等于根节点，成功
    - 否则
        - 若小于根节点，查其左子树
        - 若大于根节点，查其右子树
    - 在左右子树上的操作类似

```c
BSTree SearchBST(BSTree,KeyType key){
    if((!T)||key==T->data.key)return T;
    else if(key<T->data.key)
        return SearchBST(T->lchild,key);//在左子树中继续查找
    else
        return SearchBST(T->rchild,key);//在右子树中继续查找 
}
```

> 如何提高形态不均衡的二叉排序树的查找效率？
解决办法：做平衡化处理，尽量让二叉树的形状均衡

#### 二叉排序树的操作-插入和生成

#### 二叉排序树的操作-删除

### 平衡二叉树

## 4. 散列表的查找

### 散列表的基本概念

- `基本思想`：记录的存储位置与关键字之间存在对应关系
    - 对应关系-hash函数
    - Loc(i)=H(key)
    
- 冲突：不同的关键码映射到同一个散列地址
 
- 散列函数的构造方法
    - 直接定址法
    - 数字分析法
    - 平方取中法
    - 折叠法
    - `除留余数法`
    - 随机数法
    
- 处理冲突的方法
    - 开放定址法(开地址法)
    - 链地址法(拉链法)
    - 再散列法(双散列函数法)
    - 建立一个公共溢出区
    
